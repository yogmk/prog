;;;; a file to be loaded at startup of a lisp session
;;;; contains the definitions of frequently used
;;;; functions.


(defun atom? (x)                   ; is 'x' an atom?
    (not (listp x)))


(defun lat? (l)                    ; is 'l' a list of atoms?
    (cond
	((null l) t)
	((atom? (car l)) (lat? (cdr l)))
	(t nil)))


(defun member? (a lat)             ; is 'a' member of list 'l'?
    (cond
	((null lat) nil)
	(t (or (eq a (car lat))
	    (member? a (cdr lat))))))


(defun rember (a lat)              ; remove member 'a' from list 'lat'
    (cond
	    ((null lat) '())
		((eq (car lat) a) (cdr lat))
		(t (cons (car lat) (rember a (cdr lat))))))


(defun firsts (l)                  ; pick 1st element from lists & build a new list
    (if (null l) '()
		(cons (car (car l)) (firsts (cdr l)))))


(defun insert-R (new old lat)      ; insert 'new' to the right of 'old' in list 'l'
    (if (null lat) 
	    lat
		(if (eq (car lat) old) 
		    (cons old (cons new (cdr lat)))
		(cons (car lat) (insert-R new old (cdr lat))))))



(defun insert-L (new old lat)     ; insert 'new' to the Left of 'old' in list 'lat'
    (if (null lat) 
	    lat
		(if (eq (car lat) old)
		    (cons new (cons old (cdr lat)))
        (cons (car lat) (insert-L new old (cdr lat))))))



(defun repl (new old lat)        ; replace 'new' for 'old' in list 'lat'
    (if (null lat)
	    lat
		(if (eq (car lat) old)
		    (cons new (cdr lat))
        (cons (car lat) (repl new old (cdr lat))))))



(defun repl2 (new o1 o2 lat)     ; replace either 1st instance of 'old1' or 1st instance of 'old2' with 'new' in 'lat'
    (if (null lat)
	    lat
		(if (or (eq (car lat) o1) (eq (car lat) o2))
		    (cons new (cdr lat))
        (cons (car lat) (repl2 new o1 o2 (cdr lat))))))




(defun multirember (a lat)      ; remove all occurences of member (see rember above)
    (if (null lat)
	    lat
		(if (eq (car lat) a)
		    (multirember a (cdr lat))
        (cons (car lat) (multirember a (cdr lat))))))



(defun multi-insert-R (new old lat)  ;insert 'new' to the right of every 'old' in 'lat'
    (if (null lat)
	    lat
		(if (eq (car lat) old)
		    (cons old (cons new (multi-insert-R new old (cdr lat))))
        (cons (car lat) (multi-insert-R new old (cdr lat))))))



; multi-insert-L:

(defun multi-insert-L (new old lat)
    (if (null lat)
	  lat
	  (if (eq (car lat) old)
	    (cons new (cons old (multi-insert-L new old (cdr lat))))
	  (cons (car lat) (multi-insert-L new old (cdr lat))))))



(defun multi-repl (new old lat)     ;multi-repl: multiple substitutions
    (if (null lat)
	  lat
	  (if (eq (car lat) old)
	    (cons new (multi-repl new old (cdr lat)))
      (cons (car lat) (multi-repl new old (cdr lat))))))


;;====================
;; Numerical functions
;; May not work correctly for negative or fractional
;;====================

(defun ++ (x) (1+ x))      ;'1+' is common-lisp premitive.

(defun -- (x) (1- x))      ; ditto

;; we re-implement basic arithmetic functions in terms of above two



(defun add (m n)           ; re-implement '+' in terms of '++' & '--'
    (if (zerop n)
        m
        (add (++ m) (-- n))))

; sub: re-implement 'subtract' in terms of '--'


(defun sub (m n)           ; subtract n from m
    (if (zerop n)
	    m
		(sub (-- m) (-- n))))


;;
;; gt: re-implementation of '>' operator.
;; could also be named one of '>>', 'gt' or ':>'

(defun gt (m n)
    (cond
	    ((zerop m) nil)
		((zerop n) t)
		(t (gt (-- m) (-- n)))))

;; lt: re-implementation of '<'
;; could also have been called '<<', 'lt' or ':<'

(defun lt (m n)
    (cond
	    ((zerop n) nil)
		((zerop m) t)
		(t (lt (-- m) (-- n)))))

;; ==: re-implementation of '='
;; eq, eql & equal are predefined by lisp.

(defun == (m n)
    (if (gt m n) nil
	    (if (lt m n) nil
		t)))



(defun mlt (m n)           ; multiply 'm' by 'n'
    (if (zerop n)
	    0
		(add m (mlt m (-- n)))))



(defun div (m n)           ; div: divide 'm' by 'n'
    (if (lt m n)
	    0
		(++ (div (sub m n) n))))


